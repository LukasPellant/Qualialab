PF.Grid předpokládá, že startovní i cílové souřadnice leží uvnitř pole 0 … GRID_SIZE - 1.
Při vytváření cesty ale rovnou používáte zaokrouhlené světové souřadnice entit / cílů – a ty mohou být záporné nebo > 63. Jakmile tedy do knihovny pošlete třeba (-1, 12) nebo 64, pokusí se sáhnout na index, který v mřížce neexistuje a vnitřní kód následně narazí na undefined['-2'], což vyústí v hlášku

javascript
Copy
Edit
TypeError: Cannot read properties of undefined (reading '-2')   :contentReference[oaicite:5]{index=5}
Místo, kde se to děje
ts
Copy
Edit
const tempGrid = new PF.Grid(gridData);
return finder.findPath(from.x, from.z, to.x, to.z, tempGrid);  // ř. 25  :contentReference[oaicite:6]{index=6}
Rychlá oprava – ohraničení souřadnic v findPath
ts
Copy
Edit
// grid.ts
export function findPath(
  from: { x: number; z: number },
  to:   { x: number; z: number }
) {
  const clamp = (v: number) => Math.max(0, Math.min(GRID_SIZE - 1, v));

  const sx = clamp(from.x);
  const sz = clamp(from.z);
  const tx = clamp(to.x);
  const tz = clamp(to.z);

  // Pokud je start == cíl, nic nehledej
  if (sx === tx && sz === tz) return [];

  const tempGrid = new PF.Grid(gridData);
  return finder.findPath(sx, sz, tx, tz, tempGrid);
}
* Stačí pár řádků a knihovna nikdy nedostane neplatný index.
* Případné mimo‑rozsah hodnoty i tak zalogujete, takže rychle odhalíte špatně postavené objekty:

ts
Copy
Edit
if (from.x !== sx || from.z !== sz || to.x !== tx || to.z !== tz) {
  console.warn('Souřadnice mimo mřížku (clamp)', { from, to, sx, sz, tx, tz });
}
Lepší řešení – převod svět → mřížka na jednom místě
Pokud váš herní svět začíná uprostřed scény, je elegantnější mít drobnou konverzní funkci a stejný offset použít i při pohybu, např.:

ts
Copy
Edit
const OFFSET = GRID_SIZE / 2;

export const worldToGrid = (v: number) => Math.round(v + OFFSET);
export const gridToWorld = (v: number) => v - OFFSET;
Pak volání v assignPath vypadá takto:

ts
Copy
Edit
const path = findPath(
  { x: worldToGrid(entity.position[0]), z: worldToGrid(entity.position[2]) },
  { x: worldToGrid(target.position[0]),  z: worldToGrid(target.position[2]) }
);  :contentReference[oaicite:7]{index=7}
a v runPathSystem převádíte uzly zpět:

ts
Copy
Edit
const [nextX, nextZ] = w.path[0];
const worldNext = [gridToWorld(nextX), w.position[1], gridToWorld(nextZ)];
// … pokračuje výpočet dir/len …  :contentReference[oaicite:8]{index=8}
Tak máte jistotu, že do pathfindru vždy proudí kladné indexy, ale ve scéně může hráč pracovat s libovolnými (i zápornými) světovými souřadnicemi.

Drobná doporučení navíc
Místo	Tip
runTaskSystem	Pokud je objects.find(…) drahé, zvažte předpočítání seznamu cílů a využití filter+Math.random() pro rovnoměrnější rozdělení práce. 
runPathSystem	const speed = 0.02 * delta; používá frame‑delta, takže v 60 FPS se postava pohne ~0.0003 mřížky. Zkuste místo toho fixní hodnotu (např. speed = 2 uzly / s) a násobit delta už při přičítání.
Typy	Definujte si type Vec2 = [number, number]; type Worker = { … path?: Vec2[] } – ušetří vám to kontrolu w.path && w.path.length.

Po přidání clampingů (nebo správného offsetu) přestane chyba Cannot read properties of undefined (reading '-2') vyskakovat a pathfinding bude spolehlivě fungovat. Dej vědět, jestli se objeví další potíže!